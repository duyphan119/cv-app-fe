import { Grid, Pagination, Box } from "@mui/material";
import Head from "next/head";
import { useRouter } from "next/router";
import React from "react";
import { getAllProducts } from "../../../apis/product";
import { ProductCard } from "../../../components";
import { useGroupProductContext } from "../../../context/GroupProductContext";
import { ProductsLayout } from "../../../layouts";
import { CODE_OK, MSG_SUCCESS } from "../../../utils/constants";
import {
  Filter,
  GroupProduct,
  Product,
  ResponseItems,
} from "../../../utils/types";

type Props = {
  productData: ResponseItems<Product>;
};
const LIMIT = 24;
const Products = (props: Props) => {
  const { groupProducts } = useGroupProductContext();
  const router = useRouter();
  const { p } = router.query;
  const [filter, setFilter] = React.useState<Filter>({
    ...router.query,
    p: p ? +p : 1,
  });

  const handleChange = (p: number) => {
    setFilter((prev) => ({ ...prev, p }));
  };

  const handleFilter = (f: Filter) => {
    setFilter({ ...f, p: f.p && f.p > 1 ? 1 : f.p || 1 });
  };

  React.useEffect(() => {
    const paramsObj: any = {};
    Object.keys(filter).forEach((key: string) => {
      if (key !== "group_product_slug")
        paramsObj[key] =
          router.query[key] && filter[key as keyof Filter] === router.query[key]
            ? router.query[key]
            : filter[key as keyof Filter];
    });

    if (paramsObj.p && paramsObj.p <= 1) {
      delete paramsObj.p;
    }

    const searchParams: string = new URLSearchParams(paramsObj).toString();

    if (Object.keys(filter).length > 0 && Object.keys(paramsObj).length > 0) {
      if (Object.keys(paramsObj).length > 0)
        router.push(
          `${window.location.origin}/product/group-product/${filter.group_product_slug}?${searchParams}`
        );
      else
        router.push(
          `${window.location.origin}/product/group-product/${filter.group_product_slug}`
        );
    } else {
      router.push(
        `${window.location.origin}/product/group-product/${filter.group_product_slug}`
      );
    }
  }, [filter]);

  return (
    <ProductsLayout
      totalProducts={props.productData.count}
      onFilter={handleFilter}
      query={router.query}
      breadcrumbs={{
        links: [
          {
            href: "/",
            label: "Trang chủ",
          },
          {
            href: "/product",
            label: "Sản phẩm",
          },
        ],
        current: groupProducts.find(
          (gp: GroupProduct) => gp.slug === router.query.group_product_slug
        )?.name,
      }}
    >
      <>
        <Head>
          <title>Sản phẩm</title>
          <meta name="description" content="Generated by create next app" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
      </>
      <Grid container columnSpacing={2} rowSpacing={2}>
        {props.productData.items.map((product: Product) => {
          return (
            <Grid item xs={12} sm={6} md={3} lg={4} xl={3} key={product.id}>
              <ProductCard product={product} />
            </Grid>
          );
        })}
        {props.productData.count > 0 ? (
          <Grid item xs={12}>
            <Pagination
              count={Math.ceil(props.productData.count / LIMIT)}
              sx={{ ul: { justifyContent: "center" } }}
              variant="outlined"
              shape="rounded"
              showLastButton
              showFirstButton
              page={filter.p || 1}
              onChange={(e, page) => handleChange(page)}
            />
          </Grid>
        ) : (
          <Grid item xs={12}>
            <Box sx={{ bgcolor: "#f8bbd0", p: 2 }}>
              Không có sản phẩm phù hợp
            </Box>
          </Grid>
        )}
      </Grid>
    </ProductsLayout>
  );
};

export async function getServerSideProps(context: any) {
  const {
    group_product_slug,
    p,
    sortBy,
    sortType,
    v_ids,
    min_price,
    max_price,
  } = context.query;
  const { code, message, data } = await getAllProducts({
    group_product_slug,
    limit: LIMIT,
    product_variants: true,
    ...(p ? { p } : {}),
    ...(sortBy ? { sortBy } : {}),
    ...(sortType ? { sortType } : {}),
    ...(v_ids ? { v_ids } : {}),
    ...(min_price ? { min_price } : {}),
    ...(max_price ? { max_price } : {}),
  });
  return code === CODE_OK || message === MSG_SUCCESS
    ? {
        props: { productData: data },
      }
    : {
        notFound: true,
      };
}

export default Products;
